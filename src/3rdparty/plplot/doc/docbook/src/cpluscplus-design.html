<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Design of the PLplot C++ Interface</title><link rel="stylesheet" type="text/css" href="stylesheet.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><link rel="home" href="index.html" title="Documentation of the PLplot plotting software"><link rel="up" href="cplusplus.html" title="Chapter 9. A C++ Interface for PLplot"><link rel="prev" href="cplusplus-motivation.html" title="Motivation for the C++ Interface"><link rel="next" href="cpluscplus-specializing.html" title="Specializing the PLplot C++ Interface"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Design of the PLplot C++ Interface</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="cplusplus-motivation.html">Prev</a> </td><th width="60%" align="center">Chapter 9. A C++ Interface for PLplot</th><td width="20%" align="right"> <a accesskey="n" href="cpluscplus-specializing.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cpluscplus-design"></a>Design of the PLplot C++ Interface</h2></div></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="cpluscplus-stream"></a>Stream/Object Identity</h3></div></div></div><p>
	A C++ class named <code class="literal">plstream</code> has been introduced.  It's central
	purpose is provide a specific, object based encapsulation of the
	concept of a PLplot output stream.  Any output produced using a
	<code class="literal">plstream</code> object, will go to the PLplot output stream associated with
	that object, regardless of what stream may have been active before.
      </p><p>
	In order to write a multiple output stream PLplot application, a C++
	program can declare <code class="literal">plstream</code> objects, and invoke drawing methods on
	those objects, without regard to ordering considerations or other
	coherency considerations.  Although this has obvious simplification
	benefit even for simple programs, the full benefit is most easily
	appreciated in the context of Tk extended wish applications in which a
	<code class="literal">plstream</code> can be associated with each plframe.
      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="cpluscplus-namespace"></a>Namespace Management</h3></div></div></div><p>
	The PLplot C API is composed of a set of drawing functions, all
	prefixed with "pl", in an effort to prevent namespace collision.
	However, the prefix "pl" is gratuitous, and in particular is
	unnecessary in a C++ context.  The <code class="literal">plstream</code> class mirrors most
	of the PLplot C API, but does so by dropping the "pl" prefix.  The
	<code class="literal">plstream</code> class thus serves to collect the PLplot drawing
	functions into a scope in which collisions with other similarly named
	functions is not a concern.  So, where a C programmer might write:
      </p><pre class="programlisting">
	plsstrm( 1 );
	plenv( ... );
	plline( ... );
      </pre><p>
	The C++ programmer can write:
      </p><pre class="programlisting">
	plstream p( ... );
	p.env( ... );
	p.line( ... );
      </pre><p>
	Is that an important benefit?  The utility varies with the number of
	output streams in use in the program.
      </p><p>
	plmkstrm() is replaced by object declaration.  plsstrm() is replaced by
	method invocation on the desired output stream object.  plgstrm() is
	rendered irrelevant.
      </p><p>
	The skeptic may say, "But you have to type the same number of
	characters!  You've replaced 'pl' with 'p.', except it could be worse
	for a longer object name."  True.  BUT, in this new scheme, most plots
	will not be generated by invoking methods on a specific stream object,
	but rather by deriving from <code class="literal">plstream</code>, and invoking methods of
	"this" object.  See the section on derivation below.
      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="cpluscplus-abstraction"></a>Abstraction of Data Layout</h3></div></div></div><p>
	The <code class="literal">plstream</code> class will provide an abstract interface to the
	2-d drawing functions.  Instead of forcing the C++ user to organize
	data in one of a small set of generally brain dead data layouts with
	poor memory management properties, potentially forcing the C++ user to
	not use a superior method, or to copy data computed in one layout
	format to another for plotting (with consequent bug production), the
	<code class="literal">plstream</code> 2-d plotting functions will accept an abstract layout
	specification.  The only thing which is important to the 2-d drawing
	functions is that the data be "indexable".  They should not care about
	data layout.
      </p><p>
	Consequently, an abstract class, "Contourable_Data" is provided.  This
	class provides a pure virtual method which accepts indexes, and is to
	be made to produce a function value for the user's 2-d data field.  It
	is of no concern to PLplot how the user does this.  Any mapping
	between index and data which the user wishes to use, may be used.
      </p><p>
	This methodology allows the C++ user to compute data using whatever
	storage mechanism he wants.  Then, by deriving a class from PLplot's
	Contourable_Data abstract class, he can provide a mapping to his own
	data layout.
      </p><p>
	Note that this does /not/ mean that the C++ user's internal data
	layout must be derived from PLplot's Contourable_Data class.  Suppose
	for example that the user data is stored in a C++ "matrix" class.
	To make this data contourable, the user may define a class which
	specializes the indexing concept of the PLplot Contourable_Data class
	to his matrix class.  For example:
      </p><pre class="programlisting">
	class Matrix { ... };
	class Contourable_Matrix : public Contourable_Data {
	Matrix&amp; m;
	public:
	Contourable_Matrix( Matrix&amp; _m ) : m(_m) {}
	PLFLT  operator()( int i, int j ) const { return m(i,j); }
	};

	plstream p( ... );
	Matrix m;
	// Code to fill m with data
	Contourable_Matrix cm(m);
	p.shade( cm, ... );
      </pre><p>
	In this way the C++ user is completely freed from the tyranny of
	moronic data layout constraints imposed by PLplot's C or Fortran API.
      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="cpluscplus-callbacks"></a>Callbacks and Shades</h3></div></div></div><p>
        The <code class="literal">plstream::plshades</code> method and the other similar
        methods require callbacks for fill and pltr, mirroring the requirements
        for <code class="literal">plshades</code>. The user may specify their own callbacks or
        may use the callbacks provided by Plplot. If using Plplot callbacks the user
        has two options. They may use the appropriate C functions as described in the
        C API, however this will require direct linkage of the user's executable to
        the C library as well as the C++ library, which would otherwise not be
        necessary when using shared libraries. To avoid linking of the C library
        the user may instead utilise the functions within the <code class="literal">plcallback
        </code> namespace. The <code class="literal">plcallback</code> namespace provides
        <code class="literal">fill</code>, <code class="literal">tr0</code>, <code class="literal">tr1</code>,
        <code class="literal">tr2</code>, and <code class="literal">tr2p</code> callbacks which mirror
        the functionality of the appropriate C functions.
      </p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="cpluscplus-collapsing"></a>Collapsing the API</h3></div></div></div><p>
        Use of abstraction as in C) above will allow a single method in
        <code class="literal">plstream</code> to perform the services of multiple functions in the C API.
        In those cases where multiple functions were provided with different
        data layout specifications, but similar functionality, these can all
        be collapsed into one, through the use of the abstract interface
        technique described above.

        Moreover, function name overloading can be used to simplify the
        namespace for those cases where multiple functions were used to get
        variations on a basic capability.  For example, a single name such as
        contour or shade can be used for multiple methods taking different
        argument sets, so that for example, one can make simple plots of
        rectangular data sets, or more complex generalized coordinate
        mappings.
      </p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="cplusplus-motivation.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="cplusplus.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="cpluscplus-specializing.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Motivation for the C++ Interface </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Specializing the PLplot C++ Interface</td></tr></table></div></body></html>
